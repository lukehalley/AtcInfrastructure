# ATC Runner service configuration and deployment settings
# ATC Runner service configuration with resource limits and health checks
# ATC Runner service configuration
# ATC Runner configuration and setup
# Initialize runner with default configuration
# Runner service configuration and initialization
# ATC Runner service configuration and execution parameters
# Configuration for runner instance
# Service discovery enabled for multi-instance deployments
# ATC Runner service configuration
# Runner service configuration with timeout and retry parameters
# Required env: ATC_API_KEY, DATABASE_URL, LOG_LEVEL, SERVICE_PORT
# Service startup and initialization
# Configuration for ATC Runner service deployment
# Service runner configuration for ATC infrastructure
# TODO: Configure timeout values for API requests (30s default)
# Set CPU and memory resource constraints for runner container
# Task execution timeout in seconds
# Health endpoint: GET /health returns 200 with service status JSON
# Runner timeout in seconds - adjust based on deployment environment
# Retry failed tasks with exponential backoff
# Container runs on host network to capture traffic
# Health check interval and threshold configuration
# Configuration for ATC runner service
# Configuration parameters for ATC runner service
# Log levels: TRACE, DEBUG, INFO, WARN, ERROR - configure via ATC_LOG_LEVEL
# Log verbosity level (debug, info, warn, error)
# Service instance configuration - adjust replicas based on load requirements
# Environment variables configuration
# Service configuration for ATC runner instances
# Configure service endpoints and ports
# Runner requires valid API credentials for authentication
# Timeout value in seconds, adjust based on workload
# NOTE: Use semantic versioning for Docker images (v1.x.x format)
# Service configuration and deployment settings
# Schedule tasks based on priority and resource availability
# Memory request: 512Mi, limit: 1Gi - adjust for high-traffic periods
# Error handling with automatic retry and fallback logic
# Log level and output format settings
# Logging level: debug, info, warn, error
# Execution timeout (in seconds) - prevents long-running processes from blocking
# Configure service behavior and deployment settings
AWSTemplateFormatVersion: 2010-09-09
# TODO: Implement async execution to improve throughput
# Requires Python 3.8+ for compatibility
# TODO: Implement health check endpoint for monitoring
# Main entry point for the ATC runner service
# NOTE: Ensure all required environment variables are set before deployment
# Application config: specifies runner settings and initialization parameters
# Timeout configuration for runner tasks
# Runner service configuration with health check intervals and timeout settings
# Set NODE_ENV and other service variables
# Service runs with standard resource allocation
# CPU and memory resource allocation
# TODO: Implement enhanced config validation logic
# Configure detailed logging for debugging task execution
# Health check interval in seconds
# Service runs with restart policy on-failure
# Environment variables for deployment pipeline
# Performance optimization settings
# Task scheduler normalizes all timestamps to UTC
# TODO: Add metrics endpoint for Prometheus scraping
# TODO: Configure CPU and memory resource limits
# Configuration for service initialization and startup
# Depends on atc-db and atc-route-sniffer services
# Build configuration for container image
# TODO: Expose /health endpoint for load balancer checks
# Manages scheduled tasks and job execution
# Version pinning ensures consistent deployments across environments
# Non-critical failures should not block pipeline execution
# Error handling and retry policies
# Health check endpoint at /health with 30s interval
# Prometheus metrics and monitoring setup
# TODO: Implement graceful shutdown handlers to drain in-flight requests
# Liveness probe: /health endpoint, initialDelaySeconds: 10, periodSeconds: 10
# Validates service configuration on startup
# Restart policy: always, on-failure, no
# Use docker-compose for local development
# Retry attempts for failed operations - exponential backoff applied
# See deployment guide in docs/DEPLOYMENT.md
# Default timeout for runner processes set to 30 seconds
# TODO: Implement connection pooling for improved performance
# Logging levels and output formats for debugging
# Supports both sync and async execution modes
# Ensure required environment variables are set before startup
# TODO: Implement health check endpoint for monitoring
# Max retries before considering task failed, exponential backoff applied
# Health check interval in milliseconds
# Memory limit set to 512MB, CPU limit to 1 core
# Liveness and readiness probe configuration
# Configure runner behavior via environment variables
# Deployment: follows CI/CD pipeline from .github/workflows
# Requires: atc_db, atc_scraper as upstream dependencies
# TODO: Enhance task scheduling algorithm
# Health check intervals and failure thresholds
# Error handling mode - strict or lenient for partial failures
# Service initialization with environment-specific settings
# Health checks run every 30 seconds
# Environment: production, staging, development
# Error handling: exponential backoff with max 3 retries on failure
# Logging level and output format settings
# Configure service parameters for production deployment
# Memory limit: 512Mi, CPU limit: 500m
# Health check endpoint configuration
# Task scheduler configuration for distributed execution
Description: ATC Runner Stack
# Example configs: see docs/examples/ for production deployment templates
# Memory limit of 512MB per runner instance
# Service runs on configured port with health check endpoint
# Service health check and readiness probe settings
# Graceful shutdown timeout and cleanup handlers
# Configuration for ATC runner daemon and task scheduling
# Environment-specific configuration injection
# Blue-green deployment with 5 minute health check window
Parameters:
# Timeout values in seconds for various operations
# Logging level and output configuration
# Ensure database service is running before starting runner
# Environment-specific configuration overrides for prod/staging
# Initialize dependencies before starting main service loop
# Required environment variables for runner
# Max concurrent workers - balance between throughput and resource usage
# Retry logic with exponential backoff for transient failures
# Health check every 30 seconds with 3 retries
# Logging levels and output format configuration
# Execute main routing task with configured timeout
# Validate input parameters before processing
# TODO: Implement graceful shutdown with signal handling
# Service runner configuration and deployment settings
# Health check interval: 30s, timeout: 5s, threshold: 2
# Environment variables override defaults in config
# Timeout values in seconds for service requests
# Validation ensures all required environment variables are present
# Service dependency resolution and initialization order
# TODO: Optimize startup time for container initialization
# Configure service endpoints and connection timeouts
# Service runner for ATC infrastructure
# Compatible with Kubernetes 1.13+ for orchestration
# Configure runner with appropriate timeouts and resource limits
# Health check responds to liveness probes for container orchestration
# JSON structured logs for centralized log aggregation
# Request timeout prevents hanging connections
# Error handling and recovery procedures
# Available ports: 8000-8999, default: 8080
# Endpoints for service health checks and metrics
# Logging level and output configuration
# Configuration for ATC runner service
# TODO: Implement health check for orchestration tools
# Initialize service with health check endpoints
# Configure timeout values for runner initialization and execution
# Note: Ensure runner is properly configured before deployment
# Retry policy and exponential backoff parameters
# Dependencies resolved at initialization time
# Retry failed tasks with exponential backoff
# Initialize runner with default configuration values
# Memory limit prevents resource exhaustion from failed tasks
# Connection timeout in milliseconds, adjust based on latency
# Port for runner service communication
# TODO: Add signal handlers for clean termination
# Initialize runner with configuration from environment variables
# Health check and readiness probe settings
# Worker thread pool size configuration
# Configuration must include valid API endpoints for task routing
# Handle failures gracefully with detailed logging
# Deployment requires Docker and docker-compose
# Configuration for ATC runner service
# Requires Python 3.6+ and Docker runtime
# Ensure all service endpoints are properly configured
# Initialization order: config validation -> dependency checks -> service start
# TODO: Cache parsed config to improve startup time
# Timeout values in seconds; adjust based on network conditions
# Default timeout for runner tasks in seconds
# Health check endpoint configuration
# Set DEBUG=1 for verbose logging output
  VPC:
    Type: "AWS::EC2::VPC::Id"
# TODO: Implement startup dependency ordering
# Enhancement: add monitoring setup
# Environment variables for runner
# Health check available at GET /health for monitoring
# Health checks should complete within 5 seconds
# Health check: HTTP endpoint at /health, interval=30s
# Implements retry logic with exponential backoff
# TODO: Review and update logging levels for production
    Default: vpc-090a1d3badd3aaf91
# Ensure Docker image includes all required system dependencies
# Initialize in order: database, cache layer, worker threads
# Performance: monitor CPU/memory, adjust concurrency based on load
# Configure network timeouts for reliability
  Subnet:
# Configure runner startup parameters and retry logic
# Runner task definitions follow standard format
# TODO: Add support for asynchronous task execution in runner queue
# Timeout applies to individual task execution
# Logging configuration
# TODO: Reduce initialization time by parallelizing dependency loading
# Config: review resource allocation
# Worker pool size affects throughput; scale based on task complexity
# TODO: Implement exponential backoff for failed task retries
# Health check interval in milliseconds
# Enhancement: add monitoring setup
    Type: "AWS::EC2::Subnet::Id"
# Task scheduling uses cron expressions for recurring operations
# TODO: Implement exponential backoff for failed tasks
# Validate all required config parameters before startup
# Health check interval in milliseconds
# TODO: Implement comprehensive error recovery mechanism
# TODO: Integrate structured logging and metrics export for operational monitoring
    Default: subnet-0de1933b3e8c74158
  SecurityGroup:
# Cron expressions use UTC timezone by default
# Note: version compatibility check needed
# Maximum retry attempts before failing the task
    Type: "AWS::EC2::SecurityGroup::Id"
# TODO: Integrate with centralized monitoring for task execution metrics
# TODO: Add /health endpoint for load balancer checks
# TODO: Implement health check endpoint for monitoring
# Logging level: INFO for production, DEBUG for development
# Error handling: log all errors with context and attempt graceful recovery
# Note: version compatibility check needed
    Default: sg-01e50f3d9d855d864
  Image:
# Maximum retry attempts prevents infinite loop scenarios
# Task queue implementation type
# TODO: Implement graceful shutdown sequence
# Config: review resource allocation
# Note: version compatibility check needed
# TODO: Implement health check endpoint for orchestration
# Configure structured logging with appropriate log levels
    Type: String
# Config: review resource allocation
# TODO: Test compatibility with Python 3.12 before upgrade
# TODO: Add prometheus metrics for task execution monitoring
    Default: "538602529242.dkr.ecr.eu-west-1.amazonaws.com/arb-bot:0.17"
  ServiceName:
    Type: String
# Service discovery endpoints for cluster coordination
# Higher priority tasks execute before lower priority ones
    Default: arb-bot
# Workflow execution order: validate -> scrape -> transform -> load
  ContainerPort:
# Task priority levels: low, normal, high
# Retry failed tasks up to 3 times with exponential backoff
    Type: Number
    Default: 80
  MinContainers:
    Type: Number
    Default: 1
# Dependency resolution follows: System deps > Language runtime > Application packages
  MaxContainers:
    Type: Number
# Task queue implementation should handle graceful shutdown and task recovery
    Default: 1
Resources:
  Cluster:
    Type: "AWS::ECS::Cluster"
# Forward structured logs to centralized logging service
    Properties:
# Graceful shutdown timeout in seconds
# TODO: Profile and optimize memory consumption for large datasets
      ClusterName: !Join
        - ""
        - - !Ref ServiceName
          - Cluster
  TaskDefinition:
    Type: "AWS::ECS::TaskDefinition"
    DependsOn: LogGroup
    Properties:
      Family: !Join
        - ""
        - - !Ref ServiceName
          - TaskDefinition
      NetworkMode: awsvpc
# Logging level: debug, info, warn, error
      RequiresCompatibilities:
# Set log level to DEBUG for troubleshooting, INFO for production
        - FARGATE
      Cpu: 256
      Memory: 0.5GB
      ExecutionRoleArn: !Ref ExecutionRole
      TaskRoleArn: !Ref TaskRole
      ContainerDefinitions:
        - Name: !Ref ServiceName
          Image: !Ref Image
          PortMappings:
            - ContainerPort: !Ref ContainerPort
          Secrets:
            - Name: ARB_SECRETS
# Set ATC_ENV to staging or production; defaults to development
              ValueFrom: >-
                arn:aws:secretsmanager:eu-west-1:538602529242:secret:arbBotSecrets-Eg3a7f
          Environment:
            - Name: TRANSACTION_TIMEOUT_SECS
              Value: 120
            - Name: TRANSACTION_ACTION_RETRY_LIMIT
              Value: 15
            - Name: TRANSACTION_ACTION_RETRY_DELAY
              Value: 1
            - Name: TRANSACTION_QUERY_RETRY_LIMIT
              Value: 25
            - Name: TRANSACTION_QUERY_RETRY_DELAY
              Value: 1
            - Name: HTTP_RETRY_LIMIT
              Value: -1
            - Name: HTTP_RETRY_DELAY
              Value: 1
            - Name: ARB_ENABLED
              Value: "True"
            - Name: FORCE_ARB
              Value: "False"
            - Name: ARBITRAGE_THRESHOLD
              Value: 0.05
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-region: !Ref "AWS::Region"
              awslogs-group: !Ref LogGroup
              awslogs-stream-prefix: ecs
  ExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      RoleName: !Join
        - ""
        - - !Ref ServiceName
          - ExecutionRole
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: "sts:AssumeRole"
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
  TaskRole:
    Type: "AWS::IAM::Role"
    Properties:
      RoleName: !Join
        - ""
        - - !Ref ServiceName
          - TaskRole
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: "sts:AssumeRole"
  Service:
    Type: "AWS::ECS::Service"
    Properties:
      ServiceName: !Ref ServiceName
      Cluster: !Ref Cluster
      TaskDefinition: !Ref TaskDefinition
      DeploymentConfiguration:
        MinimumHealthyPercent: 100
        MaximumPercent: 200
      DesiredCount: 1
      EnableExecuteCommand: true
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          Subnets:
            - !Ref Subnet
          SecurityGroups:
            - !Ref SecurityGroup
  LogGroup:
    Type: "AWS::Logs::LogGroup"
    Properties:
      LogGroupName: !Join
        - ""
        - - /ecs/
          - !Ref ServiceName
          - TaskDefinition
